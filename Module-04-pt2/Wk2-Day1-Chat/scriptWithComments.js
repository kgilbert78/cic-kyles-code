// create variable for all messages. Make it an array of objects so it can store multiple messages and access information about each message more easily by using keys 
let messages = [
    // new Date() creates a date object with the current time/date in a long format to be fixed in the formatDate function
    { text: "Happy Mother's Day!", timeStamp: new Date(), sentByUser: true, },
    { text: "Thank you!", timeStamp: new Date(), sentByUser: false, }
];
// update html so initial Mother's Day messages display
updateHTML();

// function called in index file by onsubmit in form tag. pass in event as the parameter here & in html
function sendMessage(event) {
    // use event parameter to prevent default action of refreshing the page when the form is submitted
    event.preventDefault();
    // create variable and assign it the input from the html input field with the id messageInput
    const messageInput = document.getElementById("messageInput");
    // use .push to append the user input to the array "messages"
    messages.push(
        {
            // assign what the user typed to the text key (value of variable for input field)
            text: messageInput.value,
            // identify message as sent by the user for different styling and ability to edit & delete
            sentByUser: true,
            // assigns a javascript date instance (for current time) to this key, for later formatting to display in html when the message was sent
            timeStamp: new Date()
        }
    );
    // set the value in the html input back to nothing once the info the user typed is stored in the messages array, so the field goes back to blank for the next message to be typed.
    messageInput.value = "";
    // don't forget to run the function that will make all this display
    updateHTML();
    // run this function so the user will get a fake message back automatically 
    generateIncomingMessage();
}

function generateIncomingMessage() {
    // this part runs right away
    messages.push({
        text: `Javascript is pretending to type...`,
        // identify message as being created by the other "person" for different styling
        sentByUser: false,
        // set the value of this key to the current date/time with date object
        timeStamp: new Date(),
    });
    // don't forget to update html so this part will display while it's running
    updateHTML();

    // enclose function in timeout to wait 2 seconds (time at bottom as 2000) before doing the actions in the function, by passing the whole function into it as a parameter
    setTimeout(() => { // keep the curly brackets this time because of the seconds that need to go after the closing one
        // splice the last message (pretend typing) out of the array and replace it with the new message
        messages.splice(messages.length-1, 1);
        messages.push({
            text: "This response was generated by your motherboard.",
            // identify message as sent by the other "person" for different styling and to prevent user from editing or deleting
            sentByUser: false,
            timeStamp: new Date(),
        });
        // don't forget...
        updateHTML();
    }, 2000);
    
}

// manual date formatting - assign the appropriate portions of the timestamp to variables for hours, minutes. format to 12 hour clock by setting AM to true unless the hours are 12 or 0 hours (exceptions for how to display) and else set AM to false and subtract from 12 for every increment above 12 for PM. I included my attempt to fix the 12-Noon problem with includes which didn't work when it's only a portion of the string I think. add a zero to the minutes if they're a single digit. return them in a format we are used to with AM/PM in a short verson of an if/else statement.
// function formatDate(timestamp) {
//     let hours = timestamp.getHours();
//     let minutes = timestamp.getMinutes();
//     let isAM = true;
//     if (hours === 12) {
//         isAM = false;
//     } else if (hours === 0) {
//         isAM = true;
//         hours = 12;
//     } else if (hours > 12) {
//         isAM = false;
//         hours -= 12;
//     }
//     // if (hours === 12 && messages.timeStamp.includes("GMT-0400")) {
//     //     isAM = false;
//     // }
//     if (minutes < 10) {
//         minutes = `0${minutes}`;
//     }
//     return `${hours}: ${minutes} ${isAM === true ? "am" : "pm"}`;
//     console.log(hours, minutes, isAM)
// }


// Custom format to fix date and time from https://devhints.io/wip/intl-datetime loaded into function and pass in my time stamp as parameter. change "console.log" to return so I can use it in my updateHTML function, where I can pass it the current timestamp as the parameter.
function formatDate(timeStamp) {
	return new Intl.DateTimeFormat("default", 
    {
		hour: "numeric",
		minute: "numeric",
		second: "numeric",
	}
    ).format(timeStamp);
}

// ORIGINAL EDIT MESSAGE FUNCTION: IF YOU CANCEL THE MESSAGE SAYS NULL... made attempts to fix this below but couldn't.
function editMessage(messagesIndex) {
    // create variable for the new text and assign it the value entered by the user in a window prompt (with message text displayed using index passed in as parameter)
    const newMessageText = window.prompt(`Enter the new text for your message "${messages[messagesIndex].text}":`);
    // assign the new text stored in the variable to the value of the text key for the object at the index passed in as parameter
    messages[messagesIndex].text = newMessageText;
    // update html so the changes display
    updateHTML();
}

// FIRST ATTEMPT TO CORRECT THIS - message comes out blank because newMessageText is disconnected from the window.prompt
// function editMessage(messagesIndex) {
//     const newMessageText = "";
//     if (window.prompt(`Enter the new text for your message "${messages[messagesIndex].text}":`)) {
//         messages[messagesIndex].text = newMessageText;
//         updateHTML();
//     }
// }

// SECOND ATTEMPT TO CORRECT THIS - new message now goes in but else still comes out null. I don't think newMessageText is available in that part of the loop? It doesn't show up in the terminal.
// function editMessage(messagesIndex) {
//     const originalMessageText = messages[messagesIndex].text;
//     console.log("first", originalMessageText);
//     const newMessageText = window.prompt(`Enter the new text for your message "${messages[messagesIndex].text}":`);
//         if (newMessageText !== messages[messagesIndex].text) {
//             console.log("second", originalMessageText);
//             messages[messagesIndex].text = newMessageText;
//             console.log("third", originalMessageText);
//         } else {
//             console.log("fourth", originalMessageText);;
//             newMessageText = originalMessageText;
//             //messages[messagesIndex].text = originalMessageText;
//             console.log("fifth", originalMessageText);;
//         }
//         updateHTML(); 
// }

// Delete Message function - pass in the message index as parameter
function deleteMessage(messagesIndex) {
    // wrap in a pop up window to confirm delete of message with it's text displaying in the window
    if (window.confirm(`Are you sure you want to delete your message "${messages[messagesIndex].text}"?`) === true) {
        // use splice to remove the message at the index (which I got through the parameter) and remove 1
        messages.splice(messagesIndex, 1);
        // don't forget to update html so the changes display
        updateHTML();
    }
}

function updateHTML() {
    // connects to html in the index file, in div with the id "messages"
    const messagesDiv = document.getElementById("messages");
    // set new variable to empty string that can receive message content
    let htmlToUpdate = "";
    // loop to add messages. create index variable to identify messages and message variable to append key value to in order to identify which key in the object at that index number to update. ".entries" maps the right information about the messages variable to the messagesIndex and the message, but I'm confused about how it knows which information to map to which variable.
    for (const [messagesIndex, message] of messages.entries()) {
        // apply this portion of code to messages typed by the user - including css to show which messages are from the user.
        if (message.sentByUser === true) {
            // add (+=) the user entered info from sendMessage function to the htmltoUpdate variable
            htmlToUpdate += 
            // message formatting. col-2 prevents long messages from going too close to the messages from the other person so you can see they are aligned to the right. col-10 is the space for the message text and is set to align user-sent messages to the right. edit & delete buttons styled to pop up in css file. onclick set to editMessage & deleteMessage functions, with the index (from the top of the loop) in a template literal so I can pass it to those functions. 
            `<div class="row message">
                <div class="col-2"></div>
                <div class="col-10 text-end">
                <div class="buttons">
                <a onclick="editMessage(${messagesIndex})">edit</a> | <a onclick="deleteMessage(${messagesIndex})">delete</a>
                </div>
                    <span class="messageText">${message.text}</span>
                    <div class="timeStamp">${formatDate(message.timeStamp)}</div>
                </div>
            </div>`;
                    // ${message.text} .text pulls that key's value from the object saved at that index in sendMessage(), and message.timeStamp pulls that key's value and passes it to the formatDate function.
    // apply this portion of code to messages NOT sent by the user (ie. incoming messages)
        } else {
            // add (+=) the info from generateIncomingMessage function to the htmltoUpdate variable
            htmlToUpdate += 
            `<div class="row message">
                    <div class="col-10">
                        <span class="userMessageText messageText">${message.text}</span>
                        <div class="timeStamp">${formatDate(message.timeStamp)}</div>
                    </div>
                </div>`
        }
        
    }
    messagesDiv.innerHTML = htmlToUpdate; 
    // set the innerHTML of the messagesDiv to the new htmlToUpdate with the info from the new message added to it.

}